#include "/home/terra/TerraNG/terra/TerraNet.defs"

var ubyte id = getNodeId();
 
pktype msg_t from radioMsg with
	var ubyte seq;
	var ubyte l3_target;
	var ubyte l3_source;
	var ubyte l2_source;
	var ushort temp;
	var ushort[3] t;
end;
var msg_t msg_data;

#define MSG_DATA 0
#define MSG_OGM 1 // Has no ACK (layer2 nor 3)
#define MSG_ACK 2 // Layer 3
#define MSG_TYPE_COUNT 3
#define MAX_NODE_ID 88
//#define MAX_NODES 64 // Maximum node count
var ubyte[177] msg_seq; // (177 ==  (MSG_TYPE_COUNT -1) * MAX_NODE_ID + 1) ACK message uses the same seq # as DATA message
var ubyte[89] next_hop; // (89 == MAX_NODE_ID + 1) L3 routing table
//var ubyte[(MSG_TYPE_COUNT -1) * MAX_PATHS] msg_seq; // ACK message uses the same seq # as DATA message
//var ubyte[MAX_NODES-1] next_hop; // L3 routing table

// State initialization
loop i,177 do
	msg_seq[i] = 0;
end

// Node 11 is the root and should foward messages to 1
if id != 11 then
	loop i,89 do
		next_hop[i] = 0;
	end
else
	loop i,89 do
		next_hop[i] = 1;
	end
end

// Start by sending OGM (build route / hop) table

await (id/100)s; // Lets not send all at once
par do
	loop do
		//if id == 11 then
			//await (id*10)ms;
			msg_data.source = id;
			msg_data.l2_source = id;
			msg_data.target = BROADCAST;
			msg_data.type = MSG_OGM;
			msg_data.l3_source = id;
			var ubyte seq_id = MSG_OGM + (MSG_TYPE_COUNT -1) * id;
			inc msg_seq[seq_id];
			msg_data.seq = msg_seq[seq_id];
			emit SEND(msg_data);
			await SEND_DONE;
			//qPut(msg_data);
			//emit LED2(1);
			//await FOREVER; // Replace this to get periodic OGMs
			await 10s;
	//	else
	//		await FOREVER; // Only node 11 sends OGM
	//	end
	end
with
	loop do
		var msg_t ogm;
		ogm = await RECEIVE(MSG_OGM);
		var ubyte seq_id = MSG_OGM + (MSG_TYPE_COUNT -1) * ogm.l3_source;
		if ogm.seq != msg_seq[seq_id] then
			if ogm.l3_source == 44 then //DEBUG
				emit LED1(1); // DEBUG
			end
			msg_seq[seq_id] = ogm.seq;
			var ubyte l3src = ogm.l3_source;
			next_hop[l3src] = ogm.l2_source; // WTF ! DO NOT USE next_hop[ogm.l3_source]

			// Repeat the OGM
			ogm.target = BROADCAST;
			ogm.source = id;
			ogm.l2_source = id;
			qPut(ogm);
		end
	end
with
	loop do
		var msg_t dat;
		dat = await RECEIVE(MSG_DATA);
		//var ubyte seq_id = MSG_DATA + (MSG_TYPE_COUNT-1) * dat.l3_source;
		//if dat.seq != msg_seq[seq_id] then
		//	msg_seq[seq_id] = dat.seq;
			var ubyte l3tar = dat.l3_target;
			var ubyte hop = next_hop[l3tar]; // WTF ! DO NOT USE next_hop[dat.l3_target]
			if l3tar == id then
				// Message is for us, send an ack (if we have a route to the source)
				var ubyte ack_tar = dat.l3_source;
				if next_hop[ack_tar] != 0 then
					var msg_t ack;
					ack.type = MSG_ACK;
					ack.seq = dat.seq;
					ack.source = id;
					ack.target = next_hop[ack_tar];
					ack.l3_target = ack_tar;
					ack.l3_source = id;
					ack.l2_source = id;
					emit LED2(1); // DEBUG
					qPut(ack);
				end
			end
			if (l3tar != id) or (id == 11) then
				// Not for us, send to the next hop
				if hop == 0 then
					// We got data but no route to target (should never happen)
					await 1s;
				else
					// Foward the message
					dat.target = hop;
					dat.source = id;
					dat.l2_source = id;
					qPut(dat);
				end
			end
		//end
	end
with
	loop do
		if id != 44 then
			await FOREVER;
		end
		var ubyte hop = next_hop[11]; // root node
		if hop == 0 then
			// We have no route to target
			emit LED0(0);
		else
			emit REQ_TEMP();
			var ushort tValue = await TEMP();
			var ubyte seq_id = MSG_DATA + (MSG_TYPE_COUNT-1) * id; // own sequence number
			var msg_t dat; // data message

			inc msg_seq[seq_id];
			dat.type = MSG_DATA;
			dat.source = id;
			dat.l2_source = id;
			dat.target = hop;
			dat.l3_source = id;
			dat.l3_target = 11; // root node
			dat.seq = msg_seq[seq_id];
			dat.temp = tValue;
			qPut(dat);
			emit LED0(1); // DEBUG
		end
		await 4s;
	end
with
	// Send all messages in the queue
	var ubyte stat;
	var msg_t dat; // data message
	loop do
		//var ushort r = random();
		//r = r % 100;
		//await (r)ms;
		//await (id*100)ms;
		await Q_READY;
		stat = qGet(dat);
		loop do
			if stat == SUCCESS then
				var ubyte i = 0;
				loop do // To send up to 3 times
					if i == 3 then
						break;
					end
					inc i;
					par/or do
						emit SEND(dat);
						await SEND_DONE;

						// Wait for ACK from root
						var msg_t ack;
						loop do
							ack = await RECEIVE(MSG_ACK);
							// ACK has the same sequence number as the DATA
							var ubyte seq_id = MSG_DATA + (MSG_TYPE_COUNT-1) * ack.l3_source;
							if (ack.seq != msg_seq[seq_id]) and (ack.l3_target == id) then
								msg_seq[seq_id] = ack.seq;
								emit LED1(1); // DEBUG
								break;
							end
						end
					with
						// ACK timeout
						await 5s;
					end
				end
			else
				// End of queue
				break;
			end
			// Get the next from the queue
			stat = qGet(dat);
			await (id*10)ms;
		end
	end
end
